# APEX Segmented Input Plugin

This APEX item plugin offers a highly customizable input field that breaks down a single data string into multiple, visually distinct segments. It's perfect for structured data entry like account numbers, product codes, or any identifier that benefits from a segmented display, all while ensuring the entire value is stored and managed as a single string.

The plugin handles automatic padding with spaces, character validation per segment, and case conversion for both user input and displaying saved data.

**Disclaimer: This documentation was generated by an AI. While every effort has been made to ensure accuracy and completeness, please review the content carefully and verify it against your specific implementation.**

---

## Features

* **Segmented Input:** Visually separates a single input field into multiple smaller input boxes.
* **Automatic Padding:** Automatically pads each segment with spaces to its defined maximum length, ensuring fixed-length storage.
* **Character Validation:** Lets you define specific character types (Numeric, Alphabetic, Alphanumeric, or Any) for each segment, preventing invalid input.
* **Case Conversion:** Supports automatic conversion of input to uppercase or lowercase, either globally or per segment.
* **Intuitive Navigation:** Automatically moves focus to the next segment when one is filled, and allows backspace navigation to the previous segment.
* **Seamless APEX Integration:** Stores and retrieves the combined segmented value as a single item value in APEX.

---

## Installation

1.  **Download Plugin Definition:**
    * Get the `plugin.sql` file. This file contains the complete plugin definition, including its PL/SQL code and embedded JavaScript.
2.  **Import the Plugin into APEX:**
    * In your APEX application, navigate to **Shared Components** > **Plugins**.
    * Click **Import** and follow the wizard, selecting the `plugin.sql` file.

    *Note: The JavaScript code for this plugin is embedded directly within the plugin's definition in APEX. You don't need to upload a separate `.js` file.*

---

## Usage

1.  **Create a Page Item:**
    * On any APEX page, create a new **Page Item**.
    * Set its **Type** to `MTC Segmented Input [Plug-in]`.
2.  **Configure Plugin Attributes:**

    * **Number of Parts (Attribute 1):**
        * The total number of segments you want the input field to have.
        * *(Required if "Variable Length Parts" is 'N')*
    * **Lengths (Comma Separated) (Attribute 2):**
        * If **"Variable Length Parts"** is `Y`: Provide a comma-separated list of lengths for each segment (e.g., `3,4,2` for three segments of lengths 3, 4, and 2 respectively). The number of entries must match the "Number of Parts."
        * If **"Variable Length Parts"** is `N`: Provide a single number representing the fixed length for *all* segments (e.g., `5` if all segments are 5 characters long).
        * *(Required)*
    * **Global Text Case Conversion (Attribute 3):**
        * `N` (None): No global case conversion.
        * `U` (Uppercase): Convert all input characters to uppercase.
        * `L` (Lowercase): Convert all input characters to lowercase.
    * **Variable Length Parts (Attribute 4):**
        * `Y`: Each part can have a different length, defined by "Lengths (Comma Separated)."
        * `N`: All parts have the same length, defined by "Lengths (Comma Separated)."
    * **Character Patterns (Comma Separated) (Attribute 5):**
        * Define the allowed character type for each segment as a comma-separated list:
            * `N`: Numeric (0-9)
            * `A`: Alphabetic (a-z, A-Z, includes space if typed)
            * `AN`: Alphanumeric (a-z, A-Z, 0-9)
            * `AU`: Alphabetic Uppercase (a-z, A-Z converted to uppercase, includes space)
            * `ANU`: Alphanumeric Uppercase (a-z, A-Z, 0-9 converted to uppercase)
            * `ANY`: Allows any character (default if not specified for a part)
        * *(Example: `N,AU,AN,ANY` for four parts)*
    * **Minimum Length (Attribute 6):**
        * Optional. Define a minimum required length for the *entire combined* string.

3.  **Set Item Source:**
    * Make sure your item's **Source** is properly configured to retrieve the combined string from your database table.
    * **Important:** If your database column is `VARCHAR2` and might store values shorter than the total expected length, or if APEX implicitly trims the value on retrieval, it's highly recommended to **explicitly `RPAD` the value in your item's source query or function**. This ensures the plugin always receives a correctly padded string on page load.
        ```sql
        -- Example for Item Source (SQL Query returning single value):
        -- Replace YOUR_TABLE, YOUR_COLUMN, and <TOTAL_EXPECTED_LENGTH>
        SELECT RPAD(YOUR_COLUMN_NAME, <TOTAL_EXPECTED_LENGTH>, ' ')
        FROM YOUR_TABLE_NAME
        WHERE YOUR_PRIMARY_KEY_COLUMN = :P1_PRIMARY_KEY;
        ```
        The `<TOTAL_EXPECTED_LENGTH>` should be the sum of all individual segment lengths defined in your plugin attributes.

---

## How it Works

The plugin uses:
* A hidden APEX item to store the **single, combined, padded value**. This is the value that APEX submits and saves to your database.
* Multiple visible `<input type="text">` elements for the segmented user interface.

**Client-Side (JavaScript - embedded in plugin definition):**
* On page load (`apex.plugins.mtcSegmentedInput.init`), it reads the combined value from the hidden item (populated by PL/SQL) and splits it into individual segments, populating the visible input boxes. It also applies initial case conversion based on your settings.
* Event listeners (`input`, `blur`, `keydown`) on each segment handle:
    * Real-time case conversion as the user types.
    * Character validation.
    * Automatic focus management.
    * **Padding:** When a user types or when a segment loses focus, the JavaScript reads the current values from *all* visible segments, pads each individual segment with spaces to its `maxlength`, combines them into a single string, and then updates the hidden APEX item's value.

**Server-Side (PL/SQL - `render_input`):**
* Retrieves the item's value (`p_param.value`).
* **Pads `p_param.value`:** It explicitly `RPAD`s `p_param.value` to the plugin's total expected length. This is crucial because APEX might sometimes implicitly trim trailing spaces when retrieving item values from the database, which could otherwise lead to incorrect segment lengths for the plugin.
* Splits the (now guaranteed padded) `p_param.value` into `l_value_parts` based on your configured segment lengths.
* Generates the HTML for the visible input segments, pre-populating them with their respective `l_value_parts` (also ensuring these are padded in the `value` attribute) and setting up `maxlength` and `data-*` attributes for the JavaScript to use.

---

## Development Notes

* **Debugging JavaScript:** To debug the JavaScript, you can temporarily add `console.log()` statements directly into the "JavaScript Code" section of your plugin's definition in APEX. Then, open your browser's developer console (F12) to see the output.
* **PL/SQL Debugging:** Use `apex_debug.message()` in the `render_input` (and `ajax_callback` if you add one) procedures. Then, enable debug mode in your APEX application to trace server-side values and execution flow.

---
